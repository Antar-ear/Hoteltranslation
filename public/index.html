// Add this script to your index.html (replace the existing displayMessage and related functions)

// Improved display message function
function displayMessage(role, data) {
    const messagesEl = document.getElementById(role + 'Messages');
    if (!messagesEl) return;
    
    const messageEl = document.createElement('div');
    messageEl.className = `message ${data.speaker}`;
    
    // Determine what text to show based on viewer's role
    let primaryText, secondaryText, primaryLanguage, secondaryLanguage;
    
    if (role === 'guest') {
        // Guest view
        if (data.speaker === 'guest') {
            // Guest seeing their own message
            primaryText = data.original.text;  // Show original (guest language)
            secondaryText = data.translated.text;  // Show translation (English)
            primaryLanguage = data.original.language;
            secondaryLanguage = data.translated.language;
        } else {
            // Guest seeing receptionist's message
            primaryText = data.translated.text;  // Show translation (guest language)
            secondaryText = data.original.text;  // Show original (English)
            primaryLanguage = data.translated.language;
            secondaryLanguage = data.original.language;
        }
    } else if (role === 'receptionist') {
        // Receptionist view
        if (data.speaker === 'receptionist') {
            // Receptionist seeing their own message
            primaryText = data.original.text;  // Show original (English)
            secondaryText = data.translated.text;  // Show translation (guest language)
            primaryLanguage = data.original.language;
            secondaryLanguage = data.translated.language;
        } else {
            // Receptionist seeing guest's message
            primaryText = data.translated.text;  // Show translation (English)
            secondaryText = data.original.text;  // Show original (guest language)
            primaryLanguage = data.translated.language;
            secondaryLanguage = data.original.language;
        }
    }
    
    const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    
    messageEl.innerHTML = `
        <div class="message-header">
            ${data.speaker === 'guest' ? 'üë§ Guest' : 'üè® Receptionist'} 
            <span style="font-size: 0.8em; color: #666;">(${data.speaker === role ? 'You' : 'Them'})</span>
        </div>
        <div class="original-text">${escapeHtml(primaryText)}</div>
        ${secondaryText && secondaryText !== primaryText ? 
            `<div class="translated-text">Translation: ${escapeHtml(secondaryText)}</div>` : ''
        }
        <div class="audio-controls">
            <button class="play-btn" data-text="${escapeHtml(primaryText)}" data-lang="${primaryLanguage}" data-role="${role}">
                üîä Play
            </button>
            <button class="play-btn stop-btn" style="background: linear-gradient(135deg, #ff6b6b, #ee5a52);">
                üîá Stop
            </button>
        </div>
    `;
    
    // Add event listeners to buttons
    const playBtn = messageEl.querySelector('.play-btn[data-text]');
    const stopBtn = messageEl.querySelector('.stop-btn');
    
    if (playBtn) {
        playBtn.addEventListener('click', function() {
            const text = this.getAttribute('data-text');
            const lang = this.getAttribute('data-lang');
            const role = this.getAttribute('data-role');
            speakText(text, lang, role);
        });
    }
    
    if (stopBtn) {
        stopBtn.addEventListener('click', stopTTS);
    }
    
    messagesEl.appendChild(messageEl);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    
    // Auto-play only for incoming messages (not your own)
    if (ttsEnabled[role] && data.speaker !== role) {
        // Add a small delay and only play if no other audio is playing
        setTimeout(() => {
            if (!currentUtterance || currentUtterance.ended) {
                speakText(primaryText, primaryLanguage, role);
            }
        }, 500);
    }
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Improved TTS function with queue management
let ttsQueue = [];
let isPlayingTTS = false;

async function speakText(text, language, role) {
    if (!ttsEnabled[role] || !text) return;
    
    // Add to queue instead of playing immediately
    ttsQueue.push({ text, language, role });
    
    if (!isPlayingTTS) {
        playNextInQueue();
    }
}

async function playNextInQueue() {
    if (ttsQueue.length === 0) {
        isPlayingTTS = false;
        return;
    }
    
    isPlayingTTS = true;
    const { text, language, role } = ttsQueue.shift();
    
    // Check audio permissions first
    if (!audioPermissionGranted) {
        showStatus(role, 'Audio permissions required. Please allow microphone and speaker access.', 'error');
        await requestAudioPermissions(role);
        if (!audioPermissionGranted) {
            isPlayingTTS = false;
            return;
        }
    }
    
    // Resume audio context if needed
    if (audioContext && audioContext.state === 'suspended') {
        try {
            await audioContext.resume();
        } catch (error) {
            console.error('Failed to resume audio context:', error);
        }
    }
    
    // Stop any current audio
    stopCurrentAudio();
    
    // Show loading status
    showStatus(role, 'Generating speech...', 'info');
    
    try {
        // Call backend TTS API with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch('/api/tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                text: text,
                language: language 
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`TTS request failed: ${response.status}`);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        
        // Create audio element
        currentUtterance = new Audio(audioUrl);
        
        // Set playback speed
        const speedSlider = document.getElementById(role + 'Speed');
        if (speedSlider) {
            currentUtterance.playbackRate = parseFloat(speedSlider.value);
        }
        
        // Set up event listeners
        currentUtterance.onended = () => {
            URL.revokeObjectURL(audioUrl);
            currentUtterance = null;
            showStatus(role, '', 'success');
            // Play next in queue
            setTimeout(playNextInQueue, 500);
        };
        
        currentUtterance.onerror = (error) => {
            console.error('Audio playback error:', error);
            URL.revokeObjectURL(audioUrl);
            currentUtterance = null;
            showStatus(role, 'Audio playback failed', 'error');
            // Try next in queue
            setTimeout(playNextInQueue, 1000);
        };
        
        // Attempt to play audio
        const playPromise = currentUtterance.play();
        
        if (playPromise !== undefined) {
            playPromise.then(() => {
                showStatus(role, '', 'success');
            }).catch(error => {
                console.error('Audio play error:', error);
                if (error.name === 'NotAllowedError') {
                    showStatus(role, 'Click anywhere to enable audio', 'error');
                    // Add one-time click listener
                    document.addEventListener('click', function retryAudio() {
                        if (currentUtterance) {
                            currentUtterance.play().catch(console.error);
                        }
                        document.removeEventListener('click', retryAudio);
                    }, { once: true });
                } else {
                    showStatus(role, 'Audio playback failed', 'error');
                    setTimeout(playNextInQueue, 1000);
                }
            });
        }
        
    } catch (error) {
        console.error('TTS error:', error);
        if (error.name === 'AbortError') {
            showStatus(role, 'Audio generation timed out', 'error');
        } else {
            showStatus(role, 'Audio generation failed', 'error');
        }
        // Try next in queue
        setTimeout(playNextInQueue, 1000);
    }
}

function stopCurrentAudio() {
    if (currentUtterance) {
        if (currentUtterance.pause) {
            currentUtterance.pause();
            currentUtterance.currentTime = 0;
        }
        currentUtterance = null;
    }
}

function stopTTS() {
    // Clear the queue
    ttsQueue = [];
    isPlayingTTS = false;
    // Stop current audio
    stopCurrentAudio();
}

// Improved recording with minimum duration
let recordingStartTime = null;
const MIN_RECORDING_DURATION = 1000; // Minimum 1 second recording

async function toggleRecording(role) {
    const recordBtn = document.getElementById(role + 'RecordBtn');
    
    if (!isRecording) {
        // Start recording
        recordingStartTime = Date.now();
        
        // Check permissions first
        if (!audioPermissionGranted) {
            showStatus(role, 'Microphone permission required', 'error');
            await requestAudioPermissions(role);
            if (!audioPermissionGranted) {
                return;
            }
        }
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 44100
                }
            });
            
            // Check for supported MIME types
            const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' :
                           MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                           MediaRecorder.isTypeSupported('audio/ogg;codecs=opus') ? 'audio/ogg;codecs=opus' :
                           'audio/ogg';
            
            mediaRecorder = new MediaRecorder(stream, { mimeType });
            audioChunks = [];
            
            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: mimeType });
                
                // Check recording duration
                const duration = Date.now() - recordingStartTime;
                if (duration < MIN_RECORDING_DURATION) {
                    showStatus(role, 'Recording too short. Please speak for at least 1 second.', 'error');
                } else {
                    processAudio(audioBlob, role);
                }
                
                stream.getTracks().forEach(track => track.stop());
                recordingStartTime = null;
            };
            
            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event.error);
                showStatus(role, 'Recording failed', 'error');
                stream.getTracks().forEach(track => track.stop());
                recordingStartTime = null;
            };
            
            mediaRecorder.start(100); // Record in 100ms chunks for smoother processing
            isRecording = true;
            recordBtn.classList.add('recording');
            recordBtn.textContent = 'Recording...';
            showStatus(role, 'Recording... Click again to stop', 'info');
            
        } catch (error) {
            console.error('Recording permission error:', error);
            if (error.name === 'NotAllowedError') {
                showStatus(role, 'Microphone access denied. Please allow permissions.', 'error');
                audioPermissionGranted = false;
                updatePermissionStatus(role, false);
            } else {
                showStatus(role, `Recording failed: ${error.message}`, 'error');
            }
            recordingStartTime = null;
        }
    } else {
        // Stop recording
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        isRecording = false;
        recordBtn.classList.remove('recording');
        recordBtn.textContent = role === 'guest' ? 'Speak' : 'Speak (English)';
        showStatus(role, 'Processing...', 'info');
    }
}

// Debounced text input for better performance
let textInputTimeout = {};

function sendTextMessage(role) {
    // Clear any pending timeout
    if (textInputTimeout[role]) {
        clearTimeout(textInputTimeout[role]);
    }
    
    const textInput = document.getElementById(role + 'TextInput');
    const text = textInput.value.trim();
    
    if (!text) return;
    
    // Add small delay to prevent rapid submissions
    textInputTimeout[role] = setTimeout(() => {
        const language = role === 'guest' ? 
            document.getElementById('guestLanguage').value : 'en-IN';
        
        socket.emit('text_message', {
            room: currentRoom,
            role: role,
            language: language,
            text: text
        });
        
        textInput.value = '';
        showStatus(role, 'Message sent!', 'success');
    }, 300);
}
